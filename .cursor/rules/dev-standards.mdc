---
description: Core development standards for the shop-update-chatbot project
alwaysApply: true
---

# Development Standards

## Planning First

Before writing code, output a concise plan:
- Identify modules/components affected
- Nominate design patterns (Strategy, Factory, Adapter)
- Flag potential security risks

## Iterative Implementation

1. **Structure First**: Show signatures/interfaces only
2. **Wait for Approval**: Do not write implementation yet
3. **One by One**: Implement each function individually after approval

## Service Architecture (Dependency Injection)

All services must be injectable for testing and future swappability:

1. **Interface in `types.ts`**: Define the contract (what methods exist)
2. **Implementation in separate file**: Create factory function returning the interface
3. **Inject via `app.ts`**: Wire dependencies in the app container
4. **Tests use mocks**: Pass fake implementations for unit testing

Example pattern:
```typescript
// types.ts - contract
export interface MemoryManager {
  get(chatId: string): Session | undefined
  set(chatId: string, session: Session): void
}

// memory.ts - implementation
export function createInMemoryManager(timeoutMs: number): MemoryManager { ... }

// app.ts - wiring
const memory = createInMemoryManager(config.sessionTimeoutMs)
const flowController = createFlowController({ memory, ... })

// test - mock
const fakeMemory: MemoryManager = { get: vi.fn(), set: vi.fn() }
```

## Code Quality

- No comments in code (exception: explain complex "Why" logic)
- No lazy placeholders like `// ... rest of code`
- Read target file's imports, types, and indentation before generating
- Pin dependency versions exactly (no `^` or `~` ranges)

## Error Handling

- Every module must have custom error classes
- Log errors with context: `{ event, error, ...context }`
- Stop on test/build failures - analyze root cause before fixing

## Testing

- Each module gets unit tests covering success AND error cases
- Tests must verify correct error type is thrown
- Use mocks for external services (no network calls in tests)

## API Integration Checklist

When adding any external API call (WooCommerce, Green API, etc.):

1. **Implement the actual API call** - Never show success messages without calling the API
2. **Test with real API first** - Send test requests to get actual error response formats
3. **Unit test ALL error scenarios**:
   - Network error (connection refused, timeout)
   - 401 Unauthorized (invalid credentials)
   - 403 Forbidden (insufficient permissions)
   - 404 Not Found (wrong URL/resource)
   - 400 Bad Request (invalid data, duplicate entries)
   - 500+ Server errors (service unavailable)
   - JSON parse errors (malformed response)
4. **Map errors to user-friendly messages** - Users should never see raw API errors
5. **Verify success only AFTER API returns** - Never assume success before the call completes

## Logging (Pino)

| Level | Use |
|-------|-----|
| `info` | Successful operations, state transitions |
| `warn` | Ignored inputs, recoverable issues |
| `error` | Failures, exceptions |

Never log secrets (tokens, API keys).

## Finalization

1. Run validation: build, lint, test
2. Fix failures without asking
3. Only after all checks pass, confirm with user
4. Generate single git commit command on confirmation
