---
description: Core development standards for the shop-update-chatbot project
alwaysApply: true
---

# Development Standards

## Planning First

Before writing code, output a concise plan:
- Identify modules/components affected
- Nominate design patterns (Strategy, Factory, Adapter)
- Flag potential security risks

## Iterative Implementation

1. **Structure First**: Show signatures/interfaces only
2. **Wait for Approval**: Do not write implementation yet
3. **One by One**: Implement each function individually after approval

## Service Architecture (Dependency Injection)

All services must be injectable for testing and future swappability:

1. **Interface in `types.ts`**: Define the contract (what methods exist)
2. **Implementation in separate file**: Create factory function returning the interface
3. **Inject via `app.ts`**: Wire dependencies in the app container
4. **Tests use mocks**: Pass fake implementations for unit testing

Example pattern:
```typescript
// types.ts - contract
export interface MemoryManager {
  get(chatId: string): Session | undefined
  set(chatId: string, session: Session): void
}

// memory.ts - implementation
export function createInMemoryManager(timeoutMs: number): MemoryManager { ... }

// app.ts - wiring
const memory = createInMemoryManager(config.sessionTimeoutMs)
const flowController = createFlowController({ memory, ... })

// test - mock
const fakeMemory: MemoryManager = { get: vi.fn(), set: vi.fn() }
```

## Code Quality

- No comments in code (exception: explain complex "Why" logic)
- No lazy placeholders like `// ... rest of code`
- Read target file's imports, types, and indentation before generating
- Pin dependency versions exactly (no `^` or `~` ranges)

## Error Handling

- Every module must have custom error classes
- Log errors with context: `{ event, error, ...context }`
- Stop on test/build failures - analyze root cause before fixing

## Testing

- Each module gets unit tests covering success AND error cases
- Tests must verify correct error type is thrown
- Use mocks for external services (no network calls in tests)

## API Integration Checklist

When adding any external API call (WooCommerce, Green API, etc.):

1. **Implement the actual API call** - Never show success messages without calling the API
2. **Test with real API first** - Send test requests to get actual error response formats
3. **Unit test ALL error scenarios**:
   - Network error (connection refused, timeout)
   - 401 Unauthorized (invalid credentials)
   - 403 Forbidden (insufficient permissions)
   - 404 Not Found (wrong URL/resource)
   - 400 Bad Request (invalid data, duplicate entries)
   - 500+ Server errors (service unavailable)
   - JSON parse errors (malformed response)
4. **Map errors to user-friendly messages** - Users should never see raw API errors
5. **Verify success only AFTER API returns** - Never assume success before the call completes

## Docker Testing

Docker tests verify the containerized app works correctly. They run separately from unit tests (`npm run test:docker`).

### Test Structure Pattern

```typescript
describe('Docker: Test Name (docker-test:unique-name)', () => {
  const TEST_NAME = 'UNIQUE-NAME'
  const CONTAINER_NAME = 'app-unique-test'
  const PORT = 3094  // Use unique port per test suite

  // Optional: mock server for external APIs
  let mockServer: MockServer

  beforeAll(async () => {
    execSilent(`docker rm -f ${CONTAINER_NAME}`)  // Cleanup existing
    // Start mock servers if needed
    mockServer = createMockServer(PORT + 1)
    await mockServer.start()
  }, 10000)

  afterAll(async () => {
    execSilent(`docker rm -f ${CONTAINER_NAME}`)
    await mockServer?.stop()
  }, 10000)

  it('builds image', () => { /* ... */ }, 120000)  // Long timeout for build
  it('starts container', async () => { /* ... */ }, 30000)
  it('Step 1: ...', async () => { /* ... */ }, 10000)
})
```

### Key Patterns

1. **Unique ports per test suite** - Prevents port conflicts when tests run in parallel
2. **Container cleanup in beforeAll AND afterAll** - Handles both fresh runs and interrupted runs
3. **Use `host.docker.internal`** - Connect container to mock servers on host machine
4. **Redirect stderr in exec**: `execSync(command + ' 2>&1', ...)` - Docker logs go to stderr
5. **Wait for healthy** - Poll `/health` endpoint before running tests
6. **Log steps** - Use `logStep(TEST_NAME, 'description')` for debugging

### Mock Server for External APIs

When testing flows that call external APIs (WooCommerce, etc.):

```typescript
// Start mock server on host BEFORE container
mockWooServer = createMockWooCommerceServer(MOCK_PORT)
mockWooServer.setAuthCredentials('ck_test', 'cs_test')
await mockWooServer.start()

// Point container to mock via host.docker.internal
exec(`docker run -d \
  -e WOOCOMMERCE_STORE_URL=http://host.docker.internal:${MOCK_PORT} \
  -e WOOCOMMERCE_CONSUMER_KEY=ck_test \
  ...`)
```

### Helper Functions

```typescript
// Execute command and capture output (including stderr)
function exec(command: string): string {
  return execSync(command + ' 2>&1', { encoding: 'utf-8', stdio: 'pipe' })
}

// Execute silently, return success boolean
function execSilent(command: string): boolean {
  try {
    execSync(command, { encoding: 'utf-8', stdio: 'pipe' })
    return true
  } catch { return false }
}

// Wait for container to become healthy
async function waitForHealthy(url: string, timeoutMs: number): Promise<boolean> {
  const start = Date.now()
  while (Date.now() - start < timeoutMs) {
    try {
      const response = await fetch(url)
      if (response.ok) return true
    } catch {}
    await new Promise(resolve => setTimeout(resolve, 500))
  }
  return false
}
```

## Logging (Pino)

| Level | Use |
|-------|-----|
| `info` | Successful operations, state transitions |
| `warn` | Ignored inputs, recoverable issues |
| `error` | Failures, exceptions |

Never log secrets (tokens, API keys).

## Finalization

1. Run validation: build, lint, test
2. Fix failures without asking
3. Only after all checks pass, confirm with user
4. Generate single git commit command on confirmation
